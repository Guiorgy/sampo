#!/usr/bin/env bash
# Original author: Avleen Vig, 2012
# Copyright (C) Jacob Salmela, 2020 <me@jacobsalmela.com> (sampo)
#
# You can configure sampo by modifying sampo.conf
PORT=1042
LOCAL_PORT=1042
main() { 
#
# This config file is mainly for defining endpoints a client will use
# You can add any arbitrary shell code here, but it's usually easier
# to define only your endpoints the functions they should call here
# Those functions and any custom ones should be added to sampo.sh
#
# Rules usage line:
#    match_uri REGEX command [args]
#
# match_uri:
#   On an incoming request, the URI is checked against the regex.
#   If one is found, the specified command is executed with the specified arguments.
#
#   This function will also pass the results of the regex match,
#   ${BASH_REMATCH[@]} as additional arguments to the command.
#
# If you don't pass anything, this will list all of the endpints you have defined.
# This is useful for debugging when making your own endpoints and functions,
# but it just shows how you can make a function in shell code in sampo.sh
# and use the match_uri to run some arbitrary shell code
# This also serves as an easy way for your end-users to see the available endpoints and their functions by simply calling the root of the API
match_uri '^/$' \
  list_endpoints

# A simple echo endpoint to return arbitrary text
match_uri '^/echo/(.*)$' \
  serve_echo

# If the endpoint called is /issue, return the content of /etc/issue
match_uri '^/issue$' \
  serve_file \
  "/etc/issue"

# If the endpoint called is /root, return a directory listing of / using ls
match_uri '^/root$' \
  serve_dir_with_ls \
  /

# Probably the most useful to end-users is the ability to call your own scripts
# Here, we match an '/example' endpoint and then run a script residing on the server
# In a K8S setup, this works best by adding a config map with the script
match_uri '^/example$' \
  run_external_script \
  scripts/example.sh

# If you want a standard API response in JSON, there are a few examples below of how you can craft it
# It's not always pretty, but it does work
# This one uses printf to hand-craft some variables into a paylod
match_uri '^/jsonsimple$' \
  run_external_script \
  scripts/json_simple.sh

# This parses some output, and turns it into a list
match_uri '^/jsonlist$' \
  run_external_script \
  scripts/json_list.sh

# this parses the 'ls' command and makes a detailed dict payload
match_uri '^/jsoncomplex$' \
  run_external_script \
  scripts/json_complex.sh
}
#
# Create your own endpoints below
#
# match_uri '^/custom$' \
#   run_external_script \
#   scripts/yourscript.sh

# ${BASH_SOURCE[0]} is the name of the current file that the shell is reading regardless of whether it is being sourced or executed
# ${0} is the name of the current file being executed
# thus, if ${BASH_SOURCE[0]} is the same as ${0}, run the script as normal
if [[ "${BASH_SOURCE[0]}" -ef "${0}" ]]; then
  main "$@"
else
  # this script is being sourced so do not run the functions
  # this helps with unit tests and/or other scripts needing to utilize the functions defined here
  :
fi
